--
> 创建日期：2017年06月26日  
> 修改日期：2018年01月29日  

--
**nonatomic**

指非原子性访问，不加同步，多线程并发访问会提高性能。如果不加此属性，则默认是两个访问方法都为原子型事务访问。atomic是ObjectC中使用的一种线程保护技术，基本上来讲，是防止在写未完成的时候被另外一个线程读取，造成数据错误。而这种机制是耗费系统资源的，所 以在iPhone这种小型设备上，如果没有使用多线程间的通讯编程，那么nonatomic是一个非常好的选择。

**assign**

简单赋值，修改变量内容，不更改变量的索引计数，对基础数据类型(NSInteger)和C数据类型(int, float, double, char等)

当数据类型为int、float等原生类型时，可以使用assign，否则可能导致内存泄露。例如当使用alloc分配了一块内存，并把它的地址赋值给了指针a，后来如果希望指针b也共享这块内存，于是将a赋值给(assgin)b。这时就用到了assgin，此时a和b指向同一块内存。但是现在问题出现了，当a不再需要这块内存时，能都直接释放呢？肯定是不能的，因为a并不知道b是否还在使用这块内存，如果a释放了，那么b在使用这块内存的时候引起程序crash掉。

**retain属性**

retain属性就是为了解决上述问题而提出的，使用了引用计数（reference counting），还是上面那个例子，我们给那块内存设一个引用计数，当内存呗分配并且赋值给a时，引用计数是1.当把a赋值给b时引用计数增加到2.这时如果a不再使用这块内存，它只需要把引用计数减1，表明自己不再拥有这块内存。b不再使用这块内存时也把引用计数减1.当引用计数变为0的时候，代表该内存不再被任何指针所引用，系统可以直接释放掉。此时系统自动调用dealloc函数，内存被回收。

**copy属性**

copy是你不希望a和b共享一块内存时会使用到。a和b各自有自己的内存。

copy是完全复制一段栈内存，所以copy出来的对象与原来的对象是两个不同地址的对象。

好了，接下来我们看看arc模式下，strong和weak的区别及用法。

**strong**

当栈内存只要有两个或者两个以上指针指向的时候，对其中指针进行滞空操作都不会释放掉栈内存，也就是strong出来的对象，对于栈内存有控制权，还有一点，arc下默认的赋值方式就是strong。

**weak**

weak出来的两个对象的栈内存是一样的，但是当我们某一个对象滞空后，另一个对象指向的栈内存也变为空，这就是weak与strong的区别，也就是weak出来的对象，对于栈内存没有控制权。